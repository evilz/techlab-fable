Fable et la puissance de fsharp
===============================

## Objectifs

Dans cet atelier nous allons utiliser le template de base Fable et tester les diff√©rents types disponible en F# (et donc en Fable).
Puisque F# est un langage fonctionnel nous allons aussi cr√©er et combiner des fonctions entre elles (`curring` et `partial application`).


## Cr√©ation du projet

Maintenant que l'environnement de d√©veloppement est pr√™t et fonctionnel, nous pouvons utiliser le template de base Fable.

Installez le template

```shell
dotnet new -i Fable.Template
```

Si vous tapez `dotnet new -h`, vous devriez voir "fable" dans la liste des mod√®les disponibles.

``` shell
Mod√®les                                           Nom court               Langue            Balises
---------------------------------------------------------------------------------------------------------------
Console Application                               console                 [C#], F#, VB      Common/Console
Class library                                     classlib                [C#], F#, VB      Common/Library
Simple Fable App                                  fable                   F#                Fable
```

Cr√©ez une nouvelle application avec ce modele :

```shell
dotnet new fable -n FableApp -lang F#
cd FableApp
```

Lancez la restauration des d√©pendances

```
yarn
```

Et lancez l'application

```powershell
\FableApp> yarn start
yarn start v0.27.5
$ cd tools && dotnet fable webpack-dev-server -- --config webpack.config.dev.js
...
```

Navigez sur `http://localhost:8080` pour voir le site s'afficher \o/

Ouvrez le fichier `src\App.fs` et supprimez le contenu de la fonction `init()`

### Type record

Nous allons commencer par cr√©er un Record nomm√© `Person` contenant les champs `firstname` et `lastname`.
Ajoutez ce code au-dessus de la function init()


```
type Person = { lastname: string; firstname:string}
```
Si vous ex√©cutez ce code dans la `repl Fable` [ici](http://fable.io/repl/#?code=open%20Fable.Core%0Aopen%20Fable.Import%0A%0Atype%20Person%20%3D%20%7B%20lastname%3A%20string%3B%20firstname%3Astring%7D%0A%0A%0Alet%20p1%20%3D%20%7B%20Person.firstname%20%3D%20%22vincent%22%3B%20lastname%3D%22bourdon%22%7D%0Alet%20p2%20%3D%20%7B%20Person.firstname%20%3D%20%22vincent%22%3B%20lastname%3D%22bourdon%22%7D%0Alet%20e%20%3D%20p1%20%3D%20p2%0ABrowser.console.log%20e%0A&html=%3Chtml%3E%20%20%20%20%3Chead%3E%20%20%20%20%20%20%20%20%3Cmeta%20http-equiv%3DContent-Type%20content%3Dtext%2Fhtml%3Bcharset%3Dutf-8%3E%20%20%20%20%3C%2Fhead%3E%20%20%20%20%3Cbody%3E%20%20%20%20%3C%2Fbody%3E%3C%2Fhtml%3E)
vous pouvez constater que le record est transpil√© en classe Javascript. Et que la cr√©ation d'une valeur de ce type est une instance de la classe `Person`

Notez que ce type est un type Valeur et immutable. Si vous comparez deux instances qui ont exactement les m√™mes valeurs dans chaque membre il y aura √©galit√©.

Il est possible de modifier ce comportement et le code javascript g√©n√©r√©.

Ajoutez l'attribut `[<Pojo>]` sur la d√©claration du type.

```fsharp
[<Pojo>]
type Person = { lastname: string; firstname:string}
```

[fable repl](http://fable.io/repl/#?code=open%20Fable.Core%0Aopen%20Fable.Import%0A%0A%5B%3CPojo%3E%5D%0Atype%20Person%20%3D%20%7B%20lastname%3A%20string%3B%20firstname%3Astring%7D%0A%0A%0Alet%20p1%20%3D%20%7B%20Person.firstname%20%3D%20%22vincent%22%3B%20lastname%3D%22bourdon%22%7D%0Alet%20p2%20%3D%20%7B%20Person.firstname%20%3D%20%22vincent%22%3B%20lastname%3D%22bourdon%22%7D%0Alet%20e%20%3D%20p1%20%3D%20p2%0ABrowser.console.log%20e%0A&html=%3Chtml%3E%20%20%20%20%3Chead%3E%20%20%20%20%20%20%20%20%3Cmeta%20http-equiv%3DContent-Type%20content%3Dtext%2Fhtml%3Bcharset%3Dutf-8%3E%20%20%20%20%3C%2Fhead%3E%20%20%20%20%3Cbody%3E%20%20%20%20%3C%2Fbody%3E%3C%2Fhtml%3E)


Maintenant le code rendu pour une instance est un objet en notation litt√©rale et il n'y a plus d'√©galit√© sur les valeurs.

 ### Browser

Nous allons cr√©er un petit formulaire pour permettre √† l'utilisateur d'entrer son nom et pr√©nom.

Ouvrez le fichier `src\index.html`.

Remplacer le body par celui-ci :

```html
<body>
    <div id="app" class="container" ></div>
</body>
```

Et ajoutez une r√©f√©rence aux `css de bootstrap`


```html
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
```

Nous allons utiliser la div `#app` comme conteneur principal pour l'application.

Modifiez la fonction init()

```fsharp
let init() =
    let app = Browser.document.getElementById("app")
    app.innerText <- "fable APP !"
    ()
```

Webpack recharge l'application automatiquement et "fable APP!" est affich√©.


Ajoutons quelques fonctions pour nous permettre de cr√©er des composants boostrap plus facilement.


```fsharp
//=======================
// Js components
//=======================

let createForm() =
    Browser.document.createElement_form()

let createInput id placeHolder = 
    let input = Browser.document.createElement_input()
    input.id <- id
    input.placeholder <- placeHolder
    input.className <- "form-control"
    input

let createRow() =
    let row = Browser.document.createElement_div()
    row.className <- "row m-3"
    row

let createCol() =
    let col = Browser.document.createElement_div()
    col.className <- "col"
    col
```

Ce code nous permet de cr√©er quatre composants : Form, input, Row et Col.
Le code est simple, on fait appel a une Api du `document` pour cr√©er l'√©l√©ment HTML et on affecte les valeurs d√©sir√©es.
Notez qu'en F# l'affectation ce fait via `<-` et uniquement sur les valeurs `mutable`.
De plus, la derni√®re instruction est toujours retourn√©e, dans notre cas on revoie l'√©l√©ment cr√©√©.


Ajoutons une fonction pour nous permettre facilement d'ajouter un composant enfant dans un autre composant le tout avec une approche plus fonctionnelle (la fonction est ind√©pendante et non li√©e a un type, ce n'est pas une m√©thode)  

```fsharp
let appendChild (child:HTMLElement) (parent:HTMLElement) =
    parent.appendChild child :?> HTMLElement
```


Bien que le langage F# est une tr√®s puissante inf√©rence de type, je d√©sire que cette fonction utilise des `HTMLElement` et non un `Node` qui est trop g√©n√©rique et pas non plus de type trop sp√©cifique. 
On utilise `:?>` pour `downcaster` le type de retour en `HTMLElement`.

Maintenant que les composants de base sont disponibles, nous allons cr√©er une fonction pour cr√©er notre formulaire:


```fsharp
let createPersonForm() = 
    let form = createForm()
    
    let row = form |> appendChild (createRow())

    row |> appendChild (createCol()) 
        |> appendChild (createInput "firstname" "Firstname")
        |> ignore

    row |> appendChild (createCol()) 
        |> appendChild (createInput "lastname" "Lastname")
        |> ignore 

    form
```

L'op√©rateur `|>` permet de chainer les fonctions facilement en partant d'une valeur initiale. `'a -> ('a -> 'b) -> 'b`

Le code suivant
```fsharp 
let row = form |> appendChild (createRow())
```
est √©quivalent √†
```fsharp 
let row = appendChild (createRow()) form
```

Il ne reste plus qu'√† appeler cette fonction et ajouter le formulaire au composant 'app'.

```fsharp
let init() =
    let app = document.getElementById("app")
    
    app |> appendChild (createPersonForm())
```

Nos deux inputs sont affich√©s, ajoutons maintenant un bouton pour cr√©er et afficher une instance de `Person`. Mais avant cela ajoutons une autre fonction `appendChild'` qui va appeler la fonction de base et ignorer le composant de sorti de fa√ßon explicite.

```fsharp
let appendChild' child parent = appendChild child parent |> ignore
``` 

Vous pouvez utiliser cette fonction a chaque fois que le composant retourn√© n'est pas utilis√©.

Comme pour les autres composants on va cr√©er une fonction pour cr√©er un bouton et une autre pour cr√©er un simple √©l√©ment div avec du texte

```fsharp
let createBtn text onclickHandler = 
    let button = Browser.document.createElement_button()
    button.onclick <- onclickHandler
    button.textContent <- text
    button.className <- "btn btn-primary m-3"
    button

let createDivWithText text =
    let elm = Browser.document.createElement_div()
    elm.innerText <- text
    elm
```

Lors du clic sur le bouton il faudra r√©cup√©rer les valeurs des textbox et cr√©er notre record.
La premi√®re chose qui nous manque est une qui lit les inputs :

```fsharp
let getPerson() = 
    // downcast to HTMLInputElement
    let firstInput = Browser.document.getElementById("firstname") :?> HTMLInputElement
    let lastInput = Browser.document.getElementById("lastname") :?> HTMLInputElement

    {firstname= firstInput.value; lastname=lastInput.value}
```

En combinant nos fonctions nous pouvons facilement cr√©er une fonction qui prend un record `Person` en entr√© et cr√©er un `div` contenant comme texte les valeurs du record.

```fsharp
let showPerson = getPerson >> sprintf "%A" >> createDivWithText
```

Pour combiner des fonctions on utilise l'op√©rateur `>>`. 
La fonction `sprintf` sert √† cr√©er une string √† partir d'un format. Ici `%A` 


Il ne reste plus qu'√† cabler tout √ßa dans la fonction init()

```fsharp
let init() =
    let app = document.getElementById("app")
    
    app |> appendChild' (createPersonForm())

    let onclickHandler = fun (_:MouseEvent) ->
        app |> appendChild (showPerson()) :> obj

    app 
    |>  appendChild (createBtn "valid" onclickHandler)
    |> ignore
```

Vous pouvez maintenant tester le tout üéâüéâüéâ 


## It's all about type

Si le type record est surement le plus utilise ce n'est pas le seul type disponible.

Nous allons mod√©liser une liste de produit (des fruits) pour jouer avec les autres possibilit√©s offertes par F#.


### Tuple

Notre produit sera compos√© de trois √©l√©ments : son type, un libell√© et une quantit√© de vente.
Pour repr√©senter le produit nous pourrions utiliser un record. Mais cette fois nous utiliseront un tuple :

```fsharp
type Product = ProductType * ProductLabel * Quantity
```

Les √©l√©ments du tuple sont s√©par√©s par des `*` lors de la d√©finition et par des `,` lors de l'utilisation/cr√©ation.

Notre nouveau type n√©cessite trois autres types que nous allons d√©finir maintenant.

Notez qu'en F# les types doivent √™tre d√©finis avant leur utilisation (sauf syntaxe sp√©ciale).

### Union Type

Le type `ProductType` va lister les diff√©rents types de produit disponible dans l'application. 
A premi√®re vue cela ressemble √† un `enum`

```fsharp
type ProductType =
    | Apple
    | Apricot
    | Banana
    | Cherry
```

Effectivement on peut penser que cela est juste un type enum, cependant l`union apport plus qu'une simple liste de valeurs. 
Nous allons le voir en d√©finissant `Quantity`

```fsharp
 type Quantity =
    | UnitQuantity of  int 
    | KilogramQuantity of decimal 
```

Ici la quantit√© est soit unitaire et devra avoir une valeur enti√®re, soit au Kilo et devra avoir une valeur d√©cimale.

Il est aussi possible de cr√©er des `Simple/single choice`


```fsharp
type ProductLabel = ProductLabel of string
```

Ce genre de type √† deux avantages :
- il documente explicitement ce qu'est la valeur
- il interdit l'erreur d'utilisation sur des types primitifs.
Imaginez que votre application utilise des entiers pour identifier vos entit√©es. Il serait alors facile de les inverser.

 Notre produit est utilisable, ajoutons une liste de produits :

```fsharp
let productCatalog = 
    [ 
        Apple, ProductLabel("GrannySmith"), UnitQuantity(3) 
        Apple, ProductLabel("GoldenDelicious") , UnitQuantity(2) 
        Banana, ProductLabel ("Cavendish"), UnitQuantity(5) 
        Banana, ProductLabel ("GrosMichel"), UnitQuantity(3) 
        Cherry, ProductLabel ("Bing"), KilogramQuantity(0.250M) 
        Apricot, ProductLabel("Harglow"), UnitQuantity(6) 
    ]
```

Avant de pouvoir afficher nos produits dans la page il faudrait calculer le prix de vente. Pour cela nous allons utiliser deux autres types : `function type` et `mesure`


```fsharp
// mesure type 
[<Measure>] type eur
// Function type
type FruitPricer = Product -> float<eur> option
```

Comme pour le simple union, le type mesure sert d'indication et √† √©viter les erreurs. Dans notre cas le prix est en euro. 
Si on ajoutait une mesure `dol` il faudrait explicitement cr√©er une fonction de conversion.

`FruitPrice` d√©fini la signature de la fonction (comme une d√©l√©gu√© en C#). Ce type peut √™tre utilis√© comme tous les autres types puisque l'on est dans un langage fonctionnel üôå.
L'impl√©mentation devra prendre en entr√© un produit (donc un tuple) et va peut √™tre retourner un prix en float euro.

**Peut √™tre ???**

 Oui, √† la fin de la signature on retrouve le mot `option`. Option est l'impl√©mentation de la monade `Maybe` en F# qui est une union type poss√©dant deux choix `Some` avec une valeur ou `None` lorsqu'il n'y a pas de valeur.

**Pourquoi utiliser ce type ?**

Tout simple si le type de produit et la quantit√© n'est pas g√©r√©e, √† la place de lever une exception il est pr√©f√©rable de renvoyer une valeur pour ne pas mettre l'application dans un √©tat instable. De plus l'utilisateur de la fonction est averti qu'il est possible qu'il n'y ait pas toujours de prix et il devra le g√©rer.

D√©finissons l'impl√©mentation de cette fonction

```fsharp
let pricer:FruitPricer = 
    function
    | Apple,_ , UnitQuantity (q) -> Some (1.00<eur> * float(q))
    | Apricot,_ ,  UnitQuantity (q) -> Some (1.60<eur> *  float(q))
    | Banana,_ ,  UnitQuantity (q) -> Some (2.00<eur> * float(q))
    | Cherry,_ ,  KilogramQuantity (q) -> Some (1.45<eur>  * float(q))
    | _ ,_ , _  -> None
```

Nous utilisons ici un pattern matching. Cela rend les choses tr√®s explicites une fois de plus. Notez que l'on utilise `_` pour les valeurs ignor√©es et que tous les cas devront √™tre g√©r√©s, ce qui est fait √† la derni√®re ligne.

Passons √† l'interface. Ajoutez deux helpers pour cr√©er des `list`et `listItem`.

```fsharp

let createListItem innerHTML =
    let item = Browser.document.createElement_li()
    item.className <- "list-group-item"
    item.innerHTML <- innerHTML
    item

let createList items =
    let list = Browser.document.createElement_ul()
    list.className <- "list-group"
    
    items |> Seq.iter (list.appendChild >> ignore)
    list
```

Puis deux fonctions pour les composants sp√©cifiques :


```fsharp
let createProductItem pricer product = 
    let textformat = sprintf "<b>%s : %s</b> <i>%A</i>"

    let innerHtml = 
        match product with
        | Apple, ProductLabel(label), _ -> textformat "Apple" label (pricer product)
        | Apricot, ProductLabel(label), _ -> textformat "Apricot" label (pricer product)
        | Banana, ProductLabel(label), _ -> textformat "Banana" label (pricer product)
        | Cherry, ProductLabel(label), _ -> textformat "Cherry" label (pricer product)
        
    createListItem innerHtml

let showProducts pricer (catalog:Product list) = 
    catalog
    |> Seq.map (createProductItem pricer)
    |> createList
```

Il ne reste plus qu'√† appeler showProducts dans notre fonction √¨nit()`


```fsharp
let init() =
    let app = document.getElementById("app")
    
    app |> appendChild' (createPersonForm())

    let onclickHandler = fun (_:MouseEvent) ->
        app |> appendChild (showPerson()) :> obj

    app |>  appendChild' (createBtn "valid" onclickHandler)

    app |> appendChild' (showProducts pricer productCatalog)

```

# Fable Powerpack

Nous savons maintenant mod√©liser facilement nos donn√©es et m√™me nos fonctions. Cependant nous n'avons pas vu des fonctionnalit√©s essentieles pour une `single page application` : les requ√™tes AJAX, les promesses et le JSON.

Nous allons ajouter une nouvelle d√©pendance √† notre projet, dans une ligne de commande ex√©cutez :

```shell
.\.paket\paket add Fable.PowerPack -p .\src\FableApp.fsproj
```

Paket (le manager de packages) va ajouter `Fable.PowerPack` dans la liste des d√©pendances de la solution et du projet.

Vous pouvez ouvrir les modules en d√©but de fichier.

```fsharp
open Fable.PowerPack
open Fable.PowerPack.Fetch
```

### I promise, I Fetch :)

Pour notre prochain exercice nous allons r√©cup√©rer une liste d'utilisateur qui se trouve √† cette adresse : [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)

Pour ce faire nous utiliserons l'api fetch du navigateur et les `promise`.

Avant de pouvoir r√©cup√©rer la data, commen√ßons par mod√©liser un utilisateur. Nous n'allons pas r√©cup√©rer toutes les infos disponibles, mais libre √† vous d'ajouter les champs manquants.

```fsharp
[<Pojo>]
type User = {
    id: int
    name: string
    username: string
    email: string
}
```

La prochaine fonction que nous allons cr√©er utilise une fonctionnalit√© qui n'a pas encore √©t√© abord√©e jusque l√† : les `computation expression`

Pour faire simple une computation expression est un builder qui wrappe et bind/map une expression.
C'est ce qui va √™tre utilis√© pour notre promesse.
voici le code:


```fsharp
let fetchUser() =
    promise {
        let! res = fetch "https://jsonplaceholder.typicode.com/users" []
        let! users = res.json<User list>()

        return users
    }
```

Dans le bloc de notre builder promise, le `let!` est remplac√© par un `.then` et le `return` par un `resolve`.

l'√©quivalent ressemblerait √† √ßa :

```js
function fetchUser() {
    return function (builder_) {
        return builder_.Delay(function () {
            return fetch("https://jsonplaceholder.typicode.com/users", new fable_core_List())
            .then(function (_arg1) {
                return _arg1.json()
                       .then(function (_arg2) {
                    return Promise.resolve(_arg2);
                });
            });
        });
    }(Promise.promise);
}
```

Ajoutons un bouton qui va appeler cette fonction et afficher le r√©sultat dans une liste.

```fsharp
let init() =
    let app = document.getElementById("app")
    
    /// code pr√©c√©dent ...

    let fetchOnclick e =
        promise {
                try
                    let! users = fetchUser()

                    let listElm = 
                        users
                        |> Seq.map (fun u -> createListItem u.name)
                        |> createList 
                    
                    app |> appendChild' listElm 
                with
                | ex -> Browser.window.alert (sprintf "Can't featch users: %s" ex.Message) 
            } |> Promise.start
            
        obj()
           
    app |> appendChild' (createBtn "Load users" fetchOnclick)
```

La fonction `fetchOnclick` peut sembler complexe, mais pas tant que √ßa.
Une fois encore on utilise la computation expression `promise` pour extraire la valeur de retour de `fetchUser`.
Puis depuis la liste des utilisateur on cr√©e une liste de "ListItem" qui affiche le champ `name`. 
On passe toutes les ListItems √† une List (html) puis on ajoute le tout dans l'application.

En bonus, les exceptions comme les timeout sont g√©r√©es √† l'air du bloc try/with. Si une exception est lanc√©e une alerte s'affiche.

# F√©licitations üèÜ

Cet atelier est maintenant termin√© ! 
Vous avez maintenant les base pour utiliser Fable.
Nous avons pu faire le tour des diff√©rents types disponibles, `record`, `union`, `option`, `list`
 et m√™me d√©couvrir les `computation expression`.

Mais Fable est un projet encore assez jeune et plein de promesse ! 
Par manque de temps, `Elmish` n'a pas √©t√© abord√© dans cet atelier, mais j'esp√®re vous retrouvez pour un futur atelier √† ce sujet.
