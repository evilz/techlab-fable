{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Program.fs","webpack:///Program.fs"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","padWithZeros","length","str","toString","offsetToString","offset","isMinus","minutes","Math","abs","toHalfUTCString","date","half","toISOString","substring","indexOf","toStringWithCustomFormat","format","utc","replace","match","rep","y","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","h","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","toStringWithOffset","dateWithOffset","Date","getTime","Error","toStringWithKind","kind","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","getMilliseconds","getTimezoneOffset","Date_toString","Map","fable_core_Symbol","reflection","Symbol","NonDeclaredType","definition","generics","_classCallCheck","this","_createClass","key","other","_typeof","x","keys","getPropertyNames","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","Util_equals","err","return","equalsRecords","obj","propertyMap","properties","getOwnPropertyNames","Util_toString","quoteStrings","arguments","String","JSON","stringify","ToString","interfaceName","interfaces","Array","isArray","hasInterface","uci","cases","tag","data","map","join","k","v","Number","Boolean","from","ObjectRef","idMap","has","set","count","Equals","getPrototypeOf","ArrayBuffer","isView","byteLength","dv1","DataView","buffer","dv2","getUint8","WeakMap","fsFormatRegExp","toHex","formatOnce","str2","_","prefix","flags","pad","precision","toFixed","toPrecision","toExponential","toUpperCase","plusPrefix","parseInt","isNaN","ch","padLeft","input","len","isRight","cont","test","createPrinter","printer","_len2","args","_key2","strCopy","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","arg","curried","console","log"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { toString as dateToString } from \"./Date\";\nimport { escape } from \"./RegExp\";\nimport { toString } from \"./Util\";\nconst fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\n// From https://stackoverflow.com/a/13653180/3922220\nconst guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nconst StringComparison = {\n    CurrentCulture: 0,\n    CurrentCultureIgnoreCase: 1,\n    InvariantCulture: 2,\n    InvariantCultureIgnoreCase: 3,\n    Ordinal: 4,\n    OrdinalIgnoreCase: 5,\n};\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === StringComparison.CurrentCultureIgnoreCase ||\n            i === StringComparison.InvariantCultureIgnoreCase ||\n            i === StringComparison.OrdinalIgnoreCase;\n    }\n    function isOrdinal(i) {\n        return i === StringComparison.Ordinal ||\n            i === StringComparison.OrdinalIgnoreCase;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, false);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"String.indexOfAny: Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"String.indexOfAny: Length cannot be negative\");\n    }\n    if (length > str.length - startIndex) {\n        throw new Error(\"String.indexOfAny: Invalid startIndex and length\");\n    }\n    str = str.substr(startIndex, length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nfunction toHex(value) {\n    return value < 0\n        ? \"ff\" + (16777215 - (Math.abs(value) - 1)).toString(16)\n        : value.toString(16);\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function toConsole(arg) {\n    return arg.cont(console.log);\n}\nexport function toConsoleError(arg) {\n    return arg.cont(console.error);\n}\nexport function toText(arg) {\n    return arg.cont((x) => x);\n}\nexport function toFail(arg) {\n    return arg.cont((x) => { throw new Error(x); });\n}\nfunction formatOnce(str2, rep) {\n    return str2.replace(fsFormatRegExp, (_, prefix, flags, pad, precision, format) => {\n        switch (format) {\n            case \"f\":\n            case \"F\":\n                rep = rep.toFixed(precision || 6);\n                break;\n            case \"g\":\n            case \"G\":\n                rep = rep.toPrecision(precision);\n                break;\n            case \"e\":\n            case \"E\":\n                rep = rep.toExponential(precision);\n                break;\n            case \"O\":\n                rep = toString(rep);\n                break;\n            case \"A\":\n                rep = toString(rep, true);\n                break;\n            case \"x\":\n                rep = toHex(Number(rep));\n                break;\n            case \"X\":\n                rep = toHex(Number(rep)).toUpperCase();\n                break;\n        }\n        const plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep, 10) >= 0;\n        pad = parseInt(pad, 10);\n        if (!isNaN(pad)) {\n            const ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\n            rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\n        }\n        const once = prefix + (plusPrefix ? \"+\" + rep : rep);\n        return once.replace(/%/g, \"%%\");\n    });\n}\nfunction createPrinter(str, cont) {\n    const printer = (...args) => {\n        // Make a copy as the function may be used several times\n        let strCopy = str;\n        for (const arg of args) {\n            strCopy = formatOnce(strCopy, arg);\n        }\n        return fsFormatRegExp.test(strCopy)\n            ? createPrinter(strCopy, cont)\n            : cont(strCopy.replace(/%%/g, \"%\"));\n    };\n    // Mark it as curried so it doesn't\n    // get wrapped by CurriedLambda\n    printer.curried = true;\n    return printer;\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        return fsFormatRegExp.test(str)\n            ? createPrinter(str, cont)\n            : cont(str);\n    };\n}\nexport function format(str, ...args) {\n    return str.replace(formatRegExp, (match, idx, pad, pattern) => {\n        let rep = args[idx];\n        let padSymbol = \" \";\n        if (typeof rep === \"number\") {\n            switch ((pattern || \"\").substring(0, 1)) {\n                case \"f\":\n                case \"F\":\n                    rep = pattern.length > 1 ? rep.toFixed(pattern.substring(1)) : rep.toFixed(2);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = pattern.length > 1 ? rep.toPrecision(pattern.substring(1)) : rep.toPrecision();\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = pattern.length > 1 ? rep.toExponential(pattern.substring(1)) : rep.toExponential();\n                    break;\n                case \"p\":\n                case \"P\":\n                    rep = (pattern.length > 1 ? (rep * 100).toFixed(pattern.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\n                    break;\n                case \"x\":\n                    rep = toHex(Number(rep));\n                    break;\n                case \"X\":\n                    rep = toHex(Number(rep)).toUpperCase();\n                    break;\n                default:\n                    const m = /^(0+)(\\.0+)?$/.exec(pattern);\n                    if (m != null) {\n                        let decs = 0;\n                        if (m[2] != null) {\n                            rep = rep.toFixed(decs = m[2].length - 1);\n                        }\n                        pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\n                        padSymbol = \"0\";\n                    }\n                    else if (pattern) {\n                        rep = pattern;\n                    }\n            }\n        }\n        else if (typeof rep.ToString === \"function\") {\n            rep = rep.ToString(pattern);\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern);\n        }\n        pad = parseInt((pad || \"\").substring(1), 10);\n        if (!isNaN(pad)) {\n            rep = padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function join(delimiter, xs) {\n    let xs2 = typeof xs === \"string\" ? [xs] : xs;\n    const len = arguments.length;\n    if (len > 2) {\n        xs2 = Array(len - 1);\n        for (let key = 1; key < len; key++) {\n            xs2[key - 1] = arguments[key];\n        }\n    }\n    else if (!Array.isArray(xs2)) {\n        xs2 = Array.from(xs2);\n    }\n    return xs2.map((x) => toString(x)).join(delimiter);\n}\n/** Validates UUID as specified in RFC4122 (versions 1-5). Trims braces. */\nexport function validateGuid(str, doNotThrow) {\n    const trimmed = trim(str, \"both\", \"{\", \"}\");\n    if (guidRegex.test(trimmed)) {\n        return doNotThrow ? [true, trimmed] : trimmed;\n    }\n    else if (doNotThrow) {\n        return [false, \"00000000-0000-0000-0000-000000000000\"];\n    }\n    throw new Error(\"Guid should contain 32 digits with 4 dashes: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\");\n}\n/* tslint:disable */\n// From https://gist.github.com/LeverOne/1308368\nexport function newGuid() {\n    let b = '';\n    for (let a = 0; a++ < 36; b += a * 51 & 52\n        ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16)\n        : '-')\n        ;\n    return b;\n}\n// Maps for number <-> hex string conversion\nlet _convertMapsInitialized = false;\nlet _byteToHex;\nlet _hexToByte;\nfunction initConvertMaps() {\n    _byteToHex = new Array(256);\n    _hexToByte = {};\n    for (var i = 0; i < 256; i++) {\n        _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n        _hexToByte[_byteToHex[i]] = i;\n    }\n    _convertMapsInitialized = true;\n}\n/** Parse a UUID into it's component bytes */\n// Adapted from https://github.com/zefferus/uuid-parse\nexport function guidToArray(s) {\n    if (!_convertMapsInitialized) {\n        initConvertMaps();\n    }\n    let i = 0;\n    const buf = new Uint8Array(16);\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, (function (oct) {\n        switch (i) {\n            // .NET saves first three byte groups with differten endianness\n            // See https://stackoverflow.com/a/16722909/3922220\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n                buf[3 - i++] = _hexToByte[oct];\n                break;\n            case 4:\n            case 5:\n                buf[9 - i++] = _hexToByte[oct];\n                break;\n            case 6:\n            case 7:\n                buf[13 - i++] = _hexToByte[oct];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n                buf[i++] = _hexToByte[oct];\n                break;\n        }\n    }));\n    // Zero out remaining bytes if string was short\n    while (i < 16) {\n        buf[i++] = 0;\n    }\n    return buf;\n}\n/** Convert UUID byte array into a string */\nexport function arrayToGuid(buf) {\n    if (buf.length !== 16) {\n        throw new Error(\"Byte array for GUID must be exactly 16 bytes long\");\n    }\n    if (!_convertMapsInitialized) {\n        initConvertMaps();\n    }\n    return _byteToHex[buf[3]] + _byteToHex[buf[2]] +\n        _byteToHex[buf[1]] + _byteToHex[buf[0]] + '-' +\n        _byteToHex[buf[5]] + _byteToHex[buf[4]] + '-' +\n        _byteToHex[buf[7]] + _byteToHex[buf[6]] + '-' +\n        _byteToHex[buf[8]] + _byteToHex[buf[9]] + '-' +\n        _byteToHex[buf[10]] + _byteToHex[buf[11]] +\n        _byteToHex[buf[12]] + _byteToHex[buf[13]] +\n        _byteToHex[buf[14]] + _byteToHex[buf[15]];\n}\n/* tslint:enable */\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    str = String(str);\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index > input.length) {\n        throw new Error(\"System.IndexOutOfRangeException: Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, removeEmpty) {\n    count = typeof count === \"number\" ? count : null;\n    removeEmpty = typeof removeEmpty === \"number\" ? removeEmpty : null;\n    if (count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    let splitters2 = splitters;\n    if (!Array.isArray(splitters)) {\n        const len = arguments.length;\n        splitters2 = Array(len - 1);\n        for (let key = 1; key < len; key++) {\n            splitters2[key - 1] = arguments[key];\n        }\n    }\n    splitters2 = splitters2.map((x) => escape(x));\n    splitters2 = splitters2.length > 0 ? splitters2 : [\" \"];\n    let i = 0;\n    const splits = [];\n    const reg = new RegExp(splitters2.join(\"|\"), \"g\");\n    while (count == null || count > 1) {\n        const m = reg.exec(str);\n        if (m === null) {\n            break;\n        }\n        if (!removeEmpty || (m.index - i) > 0) {\n            count = count != null ? count - 1 : count;\n            splits.push(str.substring(i, m.index));\n        }\n        i = reg.lastIndex;\n    }\n    if (!removeEmpty || (str.length - i) > 0) {\n        splits.push(str.substring(i));\n    }\n    return splits;\n}\nexport function trim(str, side, ...chars) {\n    if (side === \"both\" && chars.length === 0) {\n        return str.trim();\n    }\n    if (side === \"start\" || side === \"both\") {\n        const reg = chars.length === 0 ? /^\\s+/ : new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\");\n        str = str.replace(reg, \"\");\n    }\n    if (side === \"end\" || side === \"both\") {\n        const reg = chars.length === 0 ? /\\s+$/ : new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\");\n        str = str.replace(reg, \"\");\n    }\n    return str;\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter(pred).join(\"\");\n}\n","﻿module Program\r\nopen Fable.Core\r\nprintfn \"Hello Fable 🐉\""],"sourceRoot":""}